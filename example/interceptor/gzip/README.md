# Gzip middleware
In this example, we will try to create gin server gzip middleware enabled.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Quick start](#quick-start)
  - [Code](#code)
- [Options](#options)
  - [Context Usage](#context-usage)
- [Example](#example)
    - [Start server](#start-server)
    - [Output](#output)
    - [Code](#code-1)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Quick start
Get rk-gin package from the remote repository.

```go
go get -u github.com/rookie-ninja/rk-gin
```

### Code
Add rkginmeta.Interceptor() meta with option.

```go
import     "github.com/rookie-ninja/rk-gin/interceptor/meta"
```
```go
    // ********************************************
    // ********** Enable interceptors *************
    // ********************************************
    interceptors := []gin.HandlerFunc{
        rkgingzip.Interceptor(),
    }
```

## Options

| Name | Description | Default Values |
| ---- | ---- | ---- |
| rkgingzip.WithEntryNameAndType(entryName, entryType string) | Provide entry name and type if there are multiple meta interceptors needs to be used. | gin, gin |
| rkgingzip.WithLevel(level string) | Provide level of compression, options are noCompression, bestSpeed, bestCompression, defaultCompression, huffmanOnly | defaultCompression |
| rkgingzip.WithSkipper(func(e *gin.Context) bool) | Provide skipper functions | Always return false. |

```go
    // ********************************************
    // ********** Enable interceptors *************
    // ********************************************
	interceptors := []gin.HandlerFunc{
		rkgingzip.Interceptor(
			// Entry name and entry type will be used for distinguishing interceptors. Recommended.
			// rkgingzip.WithEntryNameAndType("greeter", "gin"),
			//
			// Provide level of compression.
			// Available options are
			// - NoCompression
			// - BestSpeed
			// - BestCompression
			// - DefaultCompression
			// - HuffmanOnly
			//rkgingzip.WithLevel(rkgingzip.DefaultCompression),
			//
			// Provide skipper function
			//rkgingzip.WithSkipper(func(e *gin.Context) bool {
			//	return false
			//}),
		),
	}
```

### Context Usage
| Name | Functionality |
| ------ | ------ |
| rkginctx.GetLogger(*gin.Context) | Get logger generated by log interceptor. If there are X-Request-Id or X-Trace-Id as headers in incoming and outgoing metadata, then loggers will has requestId and traceId attached by default. |
| rkginctx.GetEvent(*gin.Context) | Get event generated by log interceptor. Event would be printed as soon as RPC finished. |
| rkginctx.GetIncomingHeaders(*gin.Context) | Get incoming header. |
| rkginctx.AddHeaderToClient(ctx, "k", "v") | Add k/v to headers which would be sent to client. This is append operation. |
| rkginctx.SetHeaderToClient(ctx, "k", "v") | Set k/v to headers which would be sent to client. |

## Example
In this example, we enable log interceptor either to monitor RPC status.

#### Start server
```shell script
$ go run post-server.go
```

#### Output
Start post-server.go and send to /rk/v1/post with encoded message.

```shell script
$ echo 'this is message' | gzip | curl --compressed --data-binary @- -H "Content-Encoding: gzip" -H "Accept-Encoding: gzip" localhost:8080/rk/v1/post
{"ReceivedMessage":"this is message\n"}
```

#### Code
- [post-server.go](post-server.go)
